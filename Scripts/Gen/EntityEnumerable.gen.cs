//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by EntityEnumerable.tt (64 `foreach` combinations)

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.ComponentModel;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Entities;

namespace StormiumTeam.Shared.Gen
{
    public static class EntityEnumerableExt
    {
        public static EntityEnumerable_D<T0> ToEnumerator_D<T0>(this ComponentSystemBase system, EntityQuery query, ref T0 d0)
            where T0 : struct, IComponentData
        { 
            return new EntityEnumerable_D<T0>(system, query, ref d0);
        }
        public static EntityEnumerable_C<T0> ToEnumerator_C<T0>(this ComponentSystemBase system, EntityQuery query, ref T0 c0)
            where T0 : class
        { 
            return new EntityEnumerable_C<T0>(system, query, ref c0);
        }
        public static EntityEnumerable_B<T0> ToEnumerator_B<T0>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0)
            where T0 : struct, IBufferElementData
        { 
            return new EntityEnumerable_B<T0>(system, query, ref b0);
        }
        public static EntityEnumerable_S<T0> ToEnumerator_S<T0>(this ComponentSystemBase system, EntityQuery query, ref T0 s0)
            where T0 : struct, ISharedComponentData
        { 
            return new EntityEnumerable_S<T0>(system, query, ref s0);
        }
        public static EntityEnumerable_DD<T0, T1> ToEnumerator_DD<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        { 
            return new EntityEnumerable_DD<T0, T1>(system, query, ref d0, ref d1);
        }
        public static EntityEnumerable_DDD<T0, T1, T2> ToEnumerator_DDD<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        { 
            return new EntityEnumerable_DDD<T0, T1, T2>(system, query, ref d0, ref d1, ref d2);
        }
        public static EntityEnumerable_DDDD<T0, T1, T2, T3> ToEnumerator_DDDD<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        { 
            return new EntityEnumerable_DDDD<T0, T1, T2, T3>(system, query, ref d0, ref d1, ref d2, ref d3);
        }
        public static EntityEnumerable_DDDDD<T0, T1, T2, T3, T4> ToEnumerator_DDDDD<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        { 
            return new EntityEnumerable_DDDDD<T0, T1, T2, T3, T4>(system, query, ref d0, ref d1, ref d2, ref d3, ref d4);
        }
        public static EntityEnumerable_DDDDDD<T0, T1, T2, T3, T4, T5> ToEnumerator_DDDDDD<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        { 
            return new EntityEnumerable_DDDDDD<T0, T1, T2, T3, T4, T5>(system, query, ref d0, ref d1, ref d2, ref d3, ref d4, ref d5);
        }
        public static EntityEnumerable_CD<T0, T1> ToEnumerator_CD<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1)
            where T0 : class
            where T1 : struct, IComponentData
        { 
            return new EntityEnumerable_CD<T0, T1>(system, query, ref c0, ref d1);
        }
        public static EntityEnumerable_CDD<T0, T1, T2> ToEnumerator_CDD<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        { 
            return new EntityEnumerable_CDD<T0, T1, T2>(system, query, ref c0, ref d1, ref d2);
        }
        public static EntityEnumerable_CDDD<T0, T1, T2, T3> ToEnumerator_CDDD<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        { 
            return new EntityEnumerable_CDDD<T0, T1, T2, T3>(system, query, ref c0, ref d1, ref d2, ref d3);
        }
        public static EntityEnumerable_CDDDD<T0, T1, T2, T3, T4> ToEnumerator_CDDDD<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        { 
            return new EntityEnumerable_CDDDD<T0, T1, T2, T3, T4>(system, query, ref c0, ref d1, ref d2, ref d3, ref d4);
        }
        public static EntityEnumerable_CDDDDD<T0, T1, T2, T3, T4, T5> ToEnumerator_CDDDDD<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        { 
            return new EntityEnumerable_CDDDDD<T0, T1, T2, T3, T4, T5>(system, query, ref c0, ref d1, ref d2, ref d3, ref d4, ref d5);
        }
        public static EntityEnumerable_BD<T0, T1> ToEnumerator_BD<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        { 
            return new EntityEnumerable_BD<T0, T1>(system, query, ref b0, ref d1);
        }
        public static EntityEnumerable_BDD<T0, T1, T2> ToEnumerator_BDD<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        { 
            return new EntityEnumerable_BDD<T0, T1, T2>(system, query, ref b0, ref d1, ref d2);
        }
        public static EntityEnumerable_BDDD<T0, T1, T2, T3> ToEnumerator_BDDD<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        { 
            return new EntityEnumerable_BDDD<T0, T1, T2, T3>(system, query, ref b0, ref d1, ref d2, ref d3);
        }
        public static EntityEnumerable_BDDDD<T0, T1, T2, T3, T4> ToEnumerator_BDDDD<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        { 
            return new EntityEnumerable_BDDDD<T0, T1, T2, T3, T4>(system, query, ref b0, ref d1, ref d2, ref d3, ref d4);
        }
        public static EntityEnumerable_BDDDDD<T0, T1, T2, T3, T4, T5> ToEnumerator_BDDDDD<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        { 
            return new EntityEnumerable_BDDDDD<T0, T1, T2, T3, T4, T5>(system, query, ref b0, ref d1, ref d2, ref d3, ref d4, ref d5);
        }
        public static EntityEnumerable_SD<T0, T1> ToEnumerator_SD<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
        { 
            return new EntityEnumerable_SD<T0, T1>(system, query, ref s0, ref d1);
        }
        public static EntityEnumerable_SDD<T0, T1, T2> ToEnumerator_SDD<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        { 
            return new EntityEnumerable_SDD<T0, T1, T2>(system, query, ref s0, ref d1, ref d2);
        }
        public static EntityEnumerable_SDDD<T0, T1, T2, T3> ToEnumerator_SDDD<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        { 
            return new EntityEnumerable_SDDD<T0, T1, T2, T3>(system, query, ref s0, ref d1, ref d2, ref d3);
        }
        public static EntityEnumerable_SDDDD<T0, T1, T2, T3, T4> ToEnumerator_SDDDD<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        { 
            return new EntityEnumerable_SDDDD<T0, T1, T2, T3, T4>(system, query, ref s0, ref d1, ref d2, ref d3, ref d4);
        }
        public static EntityEnumerable_SDDDDD<T0, T1, T2, T3, T4, T5> ToEnumerator_SDDDDD<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        { 
            return new EntityEnumerable_SDDDDD<T0, T1, T2, T3, T4, T5>(system, query, ref s0, ref d1, ref d2, ref d3, ref d4, ref d5);
        }
        public static EntityEnumerable_DC<T0, T1> ToEnumerator_DC<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1)
            where T0 : struct, IComponentData
            where T1 : class
        { 
            return new EntityEnumerable_DC<T0, T1>(system, query, ref d0, ref c1);
        }
        public static EntityEnumerable_DCC<T0, T1, T2> ToEnumerator_DCC<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
        { 
            return new EntityEnumerable_DCC<T0, T1, T2>(system, query, ref d0, ref c1, ref c2);
        }
        public static EntityEnumerable_DCCC<T0, T1, T2, T3> ToEnumerator_DCCC<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        { 
            return new EntityEnumerable_DCCC<T0, T1, T2, T3>(system, query, ref d0, ref c1, ref c2, ref c3);
        }
        public static EntityEnumerable_DCCCC<T0, T1, T2, T3, T4> ToEnumerator_DCCCC<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        { 
            return new EntityEnumerable_DCCCC<T0, T1, T2, T3, T4>(system, query, ref d0, ref c1, ref c2, ref c3, ref c4);
        }
        public static EntityEnumerable_DCCCCC<T0, T1, T2, T3, T4, T5> ToEnumerator_DCCCCC<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        { 
            return new EntityEnumerable_DCCCCC<T0, T1, T2, T3, T4, T5>(system, query, ref d0, ref c1, ref c2, ref c3, ref c4, ref c5);
        }
        public static EntityEnumerable_CC<T0, T1> ToEnumerator_CC<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1)
            where T0 : class
            where T1 : class
        { 
            return new EntityEnumerable_CC<T0, T1>(system, query, ref c0, ref c1);
        }
        public static EntityEnumerable_CCC<T0, T1, T2> ToEnumerator_CCC<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2)
            where T0 : class
            where T1 : class
            where T2 : class
        { 
            return new EntityEnumerable_CCC<T0, T1, T2>(system, query, ref c0, ref c1, ref c2);
        }
        public static EntityEnumerable_CCCC<T0, T1, T2, T3> ToEnumerator_CCCC<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
        { 
            return new EntityEnumerable_CCCC<T0, T1, T2, T3>(system, query, ref c0, ref c1, ref c2, ref c3);
        }
        public static EntityEnumerable_CCCCC<T0, T1, T2, T3, T4> ToEnumerator_CCCCC<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        { 
            return new EntityEnumerable_CCCCC<T0, T1, T2, T3, T4>(system, query, ref c0, ref c1, ref c2, ref c3, ref c4);
        }
        public static EntityEnumerable_CCCCCC<T0, T1, T2, T3, T4, T5> ToEnumerator_CCCCCC<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        { 
            return new EntityEnumerable_CCCCCC<T0, T1, T2, T3, T4, T5>(system, query, ref c0, ref c1, ref c2, ref c3, ref c4, ref c5);
        }
        public static EntityEnumerable_BC<T0, T1> ToEnumerator_BC<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : class
        { 
            return new EntityEnumerable_BC<T0, T1>(system, query, ref b0, ref c1);
        }
        public static EntityEnumerable_BCC<T0, T1, T2> ToEnumerator_BCC<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
        { 
            return new EntityEnumerable_BCC<T0, T1, T2>(system, query, ref b0, ref c1, ref c2);
        }
        public static EntityEnumerable_BCCC<T0, T1, T2, T3> ToEnumerator_BCCC<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
        { 
            return new EntityEnumerable_BCCC<T0, T1, T2, T3>(system, query, ref b0, ref c1, ref c2, ref c3);
        }
        public static EntityEnumerable_BCCCC<T0, T1, T2, T3, T4> ToEnumerator_BCCCC<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        { 
            return new EntityEnumerable_BCCCC<T0, T1, T2, T3, T4>(system, query, ref b0, ref c1, ref c2, ref c3, ref c4);
        }
        public static EntityEnumerable_BCCCCC<T0, T1, T2, T3, T4, T5> ToEnumerator_BCCCCC<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        { 
            return new EntityEnumerable_BCCCCC<T0, T1, T2, T3, T4, T5>(system, query, ref b0, ref c1, ref c2, ref c3, ref c4, ref c5);
        }
        public static EntityEnumerable_SC<T0, T1> ToEnumerator_SC<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : class
        { 
            return new EntityEnumerable_SC<T0, T1>(system, query, ref s0, ref c1);
        }
        public static EntityEnumerable_SCC<T0, T1, T2> ToEnumerator_SCC<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
        { 
            return new EntityEnumerable_SCC<T0, T1, T2>(system, query, ref s0, ref c1, ref c2);
        }
        public static EntityEnumerable_SCCC<T0, T1, T2, T3> ToEnumerator_SCCC<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        { 
            return new EntityEnumerable_SCCC<T0, T1, T2, T3>(system, query, ref s0, ref c1, ref c2, ref c3);
        }
        public static EntityEnumerable_SCCCC<T0, T1, T2, T3, T4> ToEnumerator_SCCCC<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        { 
            return new EntityEnumerable_SCCCC<T0, T1, T2, T3, T4>(system, query, ref s0, ref c1, ref c2, ref c3, ref c4);
        }
        public static EntityEnumerable_SCCCCC<T0, T1, T2, T3, T4, T5> ToEnumerator_SCCCCC<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        { 
            return new EntityEnumerable_SCCCCC<T0, T1, T2, T3, T4, T5>(system, query, ref s0, ref c1, ref c2, ref c3, ref c4, ref c5);
        }
        public static EntityEnumerable_DB<T0, T1> ToEnumerator_DB<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
        { 
            return new EntityEnumerable_DB<T0, T1>(system, query, ref d0, ref b1);
        }
        public static EntityEnumerable_DBB<T0, T1, T2> ToEnumerator_DBB<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        { 
            return new EntityEnumerable_DBB<T0, T1, T2>(system, query, ref d0, ref b1, ref b2);
        }
        public static EntityEnumerable_DBBB<T0, T1, T2, T3> ToEnumerator_DBBB<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        { 
            return new EntityEnumerable_DBBB<T0, T1, T2, T3>(system, query, ref d0, ref b1, ref b2, ref b3);
        }
        public static EntityEnumerable_DBBBB<T0, T1, T2, T3, T4> ToEnumerator_DBBBB<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        { 
            return new EntityEnumerable_DBBBB<T0, T1, T2, T3, T4>(system, query, ref d0, ref b1, ref b2, ref b3, ref b4);
        }
        public static EntityEnumerable_DBBBBB<T0, T1, T2, T3, T4, T5> ToEnumerator_DBBBBB<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        { 
            return new EntityEnumerable_DBBBBB<T0, T1, T2, T3, T4, T5>(system, query, ref d0, ref b1, ref b2, ref b3, ref b4, ref b5);
        }
        public static EntityEnumerable_CB<T0, T1> ToEnumerator_CB<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1)
            where T0 : class
            where T1 : struct, IBufferElementData
        { 
            return new EntityEnumerable_CB<T0, T1>(system, query, ref c0, ref b1);
        }
        public static EntityEnumerable_CBB<T0, T1, T2> ToEnumerator_CBB<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        { 
            return new EntityEnumerable_CBB<T0, T1, T2>(system, query, ref c0, ref b1, ref b2);
        }
        public static EntityEnumerable_CBBB<T0, T1, T2, T3> ToEnumerator_CBBB<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        { 
            return new EntityEnumerable_CBBB<T0, T1, T2, T3>(system, query, ref c0, ref b1, ref b2, ref b3);
        }
        public static EntityEnumerable_CBBBB<T0, T1, T2, T3, T4> ToEnumerator_CBBBB<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        { 
            return new EntityEnumerable_CBBBB<T0, T1, T2, T3, T4>(system, query, ref c0, ref b1, ref b2, ref b3, ref b4);
        }
        public static EntityEnumerable_CBBBBB<T0, T1, T2, T3, T4, T5> ToEnumerator_CBBBBB<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        { 
            return new EntityEnumerable_CBBBBB<T0, T1, T2, T3, T4, T5>(system, query, ref c0, ref b1, ref b2, ref b3, ref b4, ref b5);
        }
        public static EntityEnumerable_BB<T0, T1> ToEnumerator_BB<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        { 
            return new EntityEnumerable_BB<T0, T1>(system, query, ref b0, ref b1);
        }
        public static EntityEnumerable_BBB<T0, T1, T2> ToEnumerator_BBB<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        { 
            return new EntityEnumerable_BBB<T0, T1, T2>(system, query, ref b0, ref b1, ref b2);
        }
        public static EntityEnumerable_BBBB<T0, T1, T2, T3> ToEnumerator_BBBB<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        { 
            return new EntityEnumerable_BBBB<T0, T1, T2, T3>(system, query, ref b0, ref b1, ref b2, ref b3);
        }
        public static EntityEnumerable_BBBBB<T0, T1, T2, T3, T4> ToEnumerator_BBBBB<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        { 
            return new EntityEnumerable_BBBBB<T0, T1, T2, T3, T4>(system, query, ref b0, ref b1, ref b2, ref b3, ref b4);
        }
        public static EntityEnumerable_BBBBBB<T0, T1, T2, T3, T4, T5> ToEnumerator_BBBBBB<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        { 
            return new EntityEnumerable_BBBBBB<T0, T1, T2, T3, T4, T5>(system, query, ref b0, ref b1, ref b2, ref b3, ref b4, ref b5);
        }
        public static EntityEnumerable_SB<T0, T1> ToEnumerator_SB<T0, T1>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
        { 
            return new EntityEnumerable_SB<T0, T1>(system, query, ref s0, ref b1);
        }
        public static EntityEnumerable_SBB<T0, T1, T2> ToEnumerator_SBB<T0, T1, T2>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        { 
            return new EntityEnumerable_SBB<T0, T1, T2>(system, query, ref s0, ref b1, ref b2);
        }
        public static EntityEnumerable_SBBB<T0, T1, T2, T3> ToEnumerator_SBBB<T0, T1, T2, T3>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        { 
            return new EntityEnumerable_SBBB<T0, T1, T2, T3>(system, query, ref s0, ref b1, ref b2, ref b3);
        }
        public static EntityEnumerable_SBBBB<T0, T1, T2, T3, T4> ToEnumerator_SBBBB<T0, T1, T2, T3, T4>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        { 
            return new EntityEnumerable_SBBBB<T0, T1, T2, T3, T4>(system, query, ref s0, ref b1, ref b2, ref b3, ref b4);
        }
        public static EntityEnumerable_SBBBBB<T0, T1, T2, T3, T4, T5> ToEnumerator_SBBBBB<T0, T1, T2, T3, T4, T5>(this ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        { 
            return new EntityEnumerable_SBBBBB<T0, T1, T2, T3, T4, T5>(system, query, ref s0, ref b1, ref b2, ref b3, ref b4, ref b5);
        }

    public unsafe struct EntityEnumerable_D<T0>
        where T0 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_D(ComponentSystemBase system, EntityQuery query, ref T0 d0)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
        }
    }
    public unsafe struct EntityEnumerable_C<T0>
        where T0 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_C(ComponentSystemBase system, EntityQuery query, ref T0 c0)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
        }
    }
    public unsafe struct EntityEnumerable_B<T0>
        where T0 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_B(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
        }
    }
    public unsafe struct EntityEnumerable_S<T0>
        where T0 : struct, ISharedComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_S(ComponentSystemBase system, EntityQuery query, ref T0 s0)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
        }
    }
    public unsafe struct EntityEnumerable_DD<T0, T1>
        where T0 : struct, IComponentData
        where T1 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DD(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_DDD<T0, T1, T2>
        where T0 : struct, IComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DDD(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_DDDD<T0, T1, T2, T3>
        where T0 : struct, IComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DDDD(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_DDDDD<T0, T1, T2, T3, T4>
        where T0 : struct, IComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DDDDD(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_DDDDDD<T0, T1, T2, T3, T4, T5>
        where T0 : struct, IComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
        where T5 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DDDDDD(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref d5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
                    UnsafeUtility.MemCpy((byte*) Array5 + (m_EntityIndex - 1) * SizeOf5, Address5, SizeOf5);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
                    Array5 = m_Item.Chunk.GetNativeArray(ChunkComponentType5).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
                UnsafeUtility.MemCpy(Address5, (byte*) Array5 + m_EntityIndex * SizeOf5, SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public void* Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_CD<T0, T1>
        where T0 : class
        where T1 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CD(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_CDD<T0, T1, T2>
        where T0 : class
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CDD(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_CDDD<T0, T1, T2, T3>
        where T0 : class
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CDDD(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2, ref T3 d3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_CDDDD<T0, T1, T2, T3, T4>
        where T0 : class
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CDDDD(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_CDDDDD<T0, T1, T2, T3, T4, T5>
        where T0 : class
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
        where T5 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CDDDDD(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref d5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
                    UnsafeUtility.MemCpy((byte*) Array5 + (m_EntityIndex - 1) * SizeOf5, Address5, SizeOf5);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
                    Array5 = m_Item.Chunk.GetNativeArray(ChunkComponentType5).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
                UnsafeUtility.MemCpy(Address5, (byte*) Array5 + m_EntityIndex * SizeOf5, SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public void* Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_BD<T0, T1>
        where T0 : struct, IBufferElementData
        where T1 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BD(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_BDD<T0, T1, T2>
        where T0 : struct, IBufferElementData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BDD(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_BDDD<T0, T1, T2, T3>
        where T0 : struct, IBufferElementData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BDDD(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_BDDDD<T0, T1, T2, T3, T4>
        where T0 : struct, IBufferElementData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BDDDD(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_BDDDDD<T0, T1, T2, T3, T4, T5>
        where T0 : struct, IBufferElementData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
        where T5 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BDDDDD(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref d5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
                    UnsafeUtility.MemCpy((byte*) Array5 + (m_EntityIndex - 1) * SizeOf5, Address5, SizeOf5);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
                    Array5 = m_Item.Chunk.GetNativeArray(ChunkComponentType5).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
                UnsafeUtility.MemCpy(Address5, (byte*) Array5 + m_EntityIndex * SizeOf5, SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public void* Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_SD<T0, T1>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SD(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_SDD<T0, T1, T2>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SDD(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_SDDD<T0, T1, T2, T3>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SDDD(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2, ref T3 d3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_SDDDD<T0, T1, T2, T3, T4>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SDDDD(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_SDDDDD<T0, T1, T2, T3, T4, T5>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IComponentData
        where T2 : struct, IComponentData
        where T3 : struct, IComponentData
        where T4 : struct, IComponentData
        where T5 : struct, IComponentData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SDDDDD(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref d1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref d2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref d3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref d4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref d5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array1 + (m_EntityIndex - 1) * SizeOf1, Address1, SizeOf1);
                    UnsafeUtility.MemCpy((byte*) Array2 + (m_EntityIndex - 1) * SizeOf2, Address2, SizeOf2);
                    UnsafeUtility.MemCpy((byte*) Array3 + (m_EntityIndex - 1) * SizeOf3, Address3, SizeOf3);
                    UnsafeUtility.MemCpy((byte*) Array4 + (m_EntityIndex - 1) * SizeOf4, Address4, SizeOf4);
                    UnsafeUtility.MemCpy((byte*) Array5 + (m_EntityIndex - 1) * SizeOf5, Address5, SizeOf5);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetNativeArray(ChunkComponentType1).GetUnsafePtr();
                    Array2 = m_Item.Chunk.GetNativeArray(ChunkComponentType2).GetUnsafePtr();
                    Array3 = m_Item.Chunk.GetNativeArray(ChunkComponentType3).GetUnsafePtr();
                    Array4 = m_Item.Chunk.GetNativeArray(ChunkComponentType4).GetUnsafePtr();
                    Array5 = m_Item.Chunk.GetNativeArray(ChunkComponentType5).GetUnsafePtr();
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                UnsafeUtility.MemCpy(Address1, (byte*) Array1 + m_EntityIndex * SizeOf1, SizeOf1);;
                UnsafeUtility.MemCpy(Address2, (byte*) Array2 + m_EntityIndex * SizeOf2, SizeOf2);;
                UnsafeUtility.MemCpy(Address3, (byte*) Array3 + m_EntityIndex * SizeOf3, SizeOf3);;
                UnsafeUtility.MemCpy(Address4, (byte*) Array4 + m_EntityIndex * SizeOf4, SizeOf4);;
                UnsafeUtility.MemCpy(Address5, (byte*) Array5 + m_EntityIndex * SizeOf5, SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public void* Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public void* Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public void* Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public void* Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public void* Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_DC<T0, T1>
        where T0 : struct, IComponentData
        where T1 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DC(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_DCC<T0, T1, T2>
        where T0 : struct, IComponentData
        where T1 : class
        where T2 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DCC(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_DCCC<T0, T1, T2, T3>
        where T0 : struct, IComponentData
        where T1 : class
        where T2 : class
        where T3 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DCCC(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2, ref T3 c3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_DCCCC<T0, T1, T2, T3, T4>
        where T0 : struct, IComponentData
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DCCCC(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_DCCCCC<T0, T1, T2, T3, T4, T5>
        where T0 : struct, IComponentData
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
        where T5 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DCCCCC(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>();
            Address5 = Unsafe.AsPointer(ref c5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
                    Array5 = m_Item.Chunk.GetComponentObjects(ChunkComponentType5, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; Unsafe.CopyBlock(Address5, Unsafe.AsPointer(ref tmp5), (uint) SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public ArchetypeChunkComponentObjects<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_CC<T0, T1>
        where T0 : class
        where T1 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CC(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_CCC<T0, T1, T2>
        where T0 : class
        where T1 : class
        where T2 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CCC(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_CCCC<T0, T1, T2, T3>
        where T0 : class
        where T1 : class
        where T2 : class
        where T3 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CCCC(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_CCCCC<T0, T1, T2, T3, T4>
        where T0 : class
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CCCCC(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_CCCCCC<T0, T1, T2, T3, T4, T5>
        where T0 : class
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
        where T5 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CCCCCC(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>();
            Address5 = Unsafe.AsPointer(ref c5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
                    Array5 = m_Item.Chunk.GetComponentObjects(ChunkComponentType5, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; Unsafe.CopyBlock(Address5, Unsafe.AsPointer(ref tmp5), (uint) SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public ArchetypeChunkComponentObjects<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_BC<T0, T1>
        where T0 : struct, IBufferElementData
        where T1 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BC(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_BCC<T0, T1, T2>
        where T0 : struct, IBufferElementData
        where T1 : class
        where T2 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BCC(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_BCCC<T0, T1, T2, T3>
        where T0 : struct, IBufferElementData
        where T1 : class
        where T2 : class
        where T3 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BCCC(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_BCCCC<T0, T1, T2, T3, T4>
        where T0 : struct, IBufferElementData
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BCCCC(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_BCCCCC<T0, T1, T2, T3, T4, T5>
        where T0 : struct, IBufferElementData
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
        where T5 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BCCCCC(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>();
            Address5 = Unsafe.AsPointer(ref c5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
                    Array5 = m_Item.Chunk.GetComponentObjects(ChunkComponentType5, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; Unsafe.CopyBlock(Address5, Unsafe.AsPointer(ref tmp5), (uint) SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public ArchetypeChunkComponentObjects<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_SC<T0, T1>
        where T0 : struct, ISharedComponentData
        where T1 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SC(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_SCC<T0, T1, T2>
        where T0 : struct, ISharedComponentData
        where T1 : class
        where T2 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SCC(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_SCCC<T0, T1, T2, T3>
        where T0 : struct, ISharedComponentData
        where T1 : class
        where T2 : class
        where T3 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SCCC(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2, ref T3 c3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_SCCCC<T0, T1, T2, T3, T4>
        where T0 : struct, ISharedComponentData
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SCCCC(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_SCCCCC<T0, T1, T2, T3, T4, T5>
        where T0 : struct, ISharedComponentData
        where T1 : class
        where T2 : class
        where T3 : class
        where T4 : class
        where T5 : class
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SCCCCC(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkComponentType<T1>();
            Address1 = Unsafe.AsPointer(ref c1);
            ChunkComponentType2 = system.GetArchetypeChunkComponentType<T2>();
            Address2 = Unsafe.AsPointer(ref c2);
            ChunkComponentType3 = system.GetArchetypeChunkComponentType<T3>();
            Address3 = Unsafe.AsPointer(ref c3);
            ChunkComponentType4 = system.GetArchetypeChunkComponentType<T4>();
            Address4 = Unsafe.AsPointer(ref c4);
            ChunkComponentType5 = system.GetArchetypeChunkComponentType<T5>();
            Address5 = Unsafe.AsPointer(ref c5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<IntPtr>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkComponentType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkComponentType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkComponentType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkComponentType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkComponentType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetComponentObjects(ChunkComponentType1, System.EntityManager);
                    Array2 = m_Item.Chunk.GetComponentObjects(ChunkComponentType2, System.EntityManager);
                    Array3 = m_Item.Chunk.GetComponentObjects(ChunkComponentType3, System.EntityManager);
                    Array4 = m_Item.Chunk.GetComponentObjects(ChunkComponentType4, System.EntityManager);
                    Array5 = m_Item.Chunk.GetComponentObjects(ChunkComponentType5, System.EntityManager);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; Unsafe.CopyBlock(Address1, Unsafe.AsPointer(ref tmp1), (uint) SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; Unsafe.CopyBlock(Address2, Unsafe.AsPointer(ref tmp2), (uint) SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; Unsafe.CopyBlock(Address3, Unsafe.AsPointer(ref tmp3), (uint) SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; Unsafe.CopyBlock(Address4, Unsafe.AsPointer(ref tmp4), (uint) SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; Unsafe.CopyBlock(Address5, Unsafe.AsPointer(ref tmp5), (uint) SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkComponentType<T1> ChunkComponentType1;
            public void* Address1;
            public ArchetypeChunkComponentObjects<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkComponentType<T2> ChunkComponentType2;
            public void* Address2;
            public ArchetypeChunkComponentObjects<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkComponentType<T3> ChunkComponentType3;
            public void* Address3;
            public ArchetypeChunkComponentObjects<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkComponentType<T4> ChunkComponentType4;
            public void* Address4;
            public ArchetypeChunkComponentObjects<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkComponentType<T5> ChunkComponentType5;
            public void* Address5;
            public ArchetypeChunkComponentObjects<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_DB<T0, T1>
        where T0 : struct, IComponentData
        where T1 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DB(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_DBB<T0, T1, T2>
        where T0 : struct, IComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DBB(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_DBBB<T0, T1, T2, T3>
        where T0 : struct, IComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DBBB(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_DBBBB<T0, T1, T2, T3, T4>
        where T0 : struct, IComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DBBBB(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_DBBBBB<T0, T1, T2, T3, T4, T5>
        where T0 : struct, IComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
        where T5 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_DBBBBB(ComponentSystemBase system, EntityQuery query, ref T0 d0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref d0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
            ChunkComponentType5 = system.GetArchetypeChunkBufferType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref b5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkBufferType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
                    UnsafeUtility.MemCpy((byte*) Array0 + (m_EntityIndex - 1) * SizeOf0, Address0, SizeOf0);
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetNativeArray(ChunkComponentType0).GetUnsafePtr();
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
                    Array5 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType5);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, (byte*) Array0 + m_EntityIndex * SizeOf0, SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; UnsafeUtility.MemCpy(Address5, UnsafeUtility.AddressOf(ref tmp5), SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public void* Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkBufferType<T5> ChunkComponentType5;
            public void* Address5;
            public BufferAccessor<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_CB<T0, T1>
        where T0 : class
        where T1 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CB(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_CBB<T0, T1, T2>
        where T0 : class
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CBB(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_CBBB<T0, T1, T2, T3>
        where T0 : class
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CBBB(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_CBBBB<T0, T1, T2, T3, T4>
        where T0 : class
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CBBBB(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_CBBBBB<T0, T1, T2, T3, T4, T5>
        where T0 : class
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
        where T5 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_CBBBBB(ComponentSystemBase system, EntityQuery query, ref T0 c0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkComponentType<T0>();
            Address0 = Unsafe.AsPointer(ref c0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
            ChunkComponentType5 = system.GetArchetypeChunkBufferType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref b5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<IntPtr>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkBufferType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetComponentObjects(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
                    Array5 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType5);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; Unsafe.CopyBlock(Address0, Unsafe.AsPointer(ref tmp0), (uint) SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; UnsafeUtility.MemCpy(Address5, UnsafeUtility.AddressOf(ref tmp5), SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public ArchetypeChunkComponentObjects<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkBufferType<T5> ChunkComponentType5;
            public void* Address5;
            public BufferAccessor<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_BB<T0, T1>
        where T0 : struct, IBufferElementData
        where T1 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BB(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_BBB<T0, T1, T2>
        where T0 : struct, IBufferElementData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BBB(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_BBBB<T0, T1, T2, T3>
        where T0 : struct, IBufferElementData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BBBB(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_BBBBB<T0, T1, T2, T3, T4>
        where T0 : struct, IBufferElementData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BBBBB(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_BBBBBB<T0, T1, T2, T3, T4, T5>
        where T0 : struct, IBufferElementData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
        where T5 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_BBBBBB(ComponentSystemBase system, EntityQuery query, ref DynamicBuffer<T0> b0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkBufferType<T0>(false);
            Address0 = UnsafeUtility.AddressOf(ref b0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
            ChunkComponentType5 = system.GetArchetypeChunkBufferType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref b5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkBufferType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkBufferType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType0);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
                    Array5 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType5);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                var tmp0 = Array0[m_EntityIndex]; UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref tmp0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; UnsafeUtility.MemCpy(Address5, UnsafeUtility.AddressOf(ref tmp5), SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkBufferType<T0> ChunkComponentType0;
            public void* Address0;
            public BufferAccessor<T0> Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkBufferType<T5> ChunkComponentType5;
            public void* Address5;
            public BufferAccessor<T5> Array5;
            public int SizeOf5;
        }
    }
    public unsafe struct EntityEnumerable_SB<T0, T1>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SB(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
        }
    }
    public unsafe struct EntityEnumerable_SBB<T0, T1, T2>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SBB(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
        }
    }
    public unsafe struct EntityEnumerable_SBBB<T0, T1, T2, T3>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SBBB(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
        }
    }
    public unsafe struct EntityEnumerable_SBBBB<T0, T1, T2, T3, T4>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SBBBB(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
        }
    }
    public unsafe struct EntityEnumerable_SBBBBB<T0, T1, T2, T3, T4, T5>
        where T0 : struct, ISharedComponentData
        where T1 : struct, IBufferElementData
        where T2 : struct, IBufferElementData
        where T3 : struct, IBufferElementData
        where T4 : struct, IBufferElementData
        where T5 : struct, IBufferElementData
    {
        public struct Item
        {
			public int            Iteration;
			public Entity         Entity;
			public ArchetypeChunk Chunk;

			public int IndexInChunk;
			
			public void Deconstruct(out Entity entity)
			{
				entity       = Entity;
			}
			
			public void Deconstruct(out int iteration)
			{
				iteration    = Iteration;
			}

			public void Deconstruct(out int iteration, out Entity entity)
			{
				iteration    = Iteration;
				entity       = Entity;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk)
			{
				iteration = Iteration;
				entity    = Entity;
				chunk     = Chunk;
			}

			public void Deconstruct(out int iteration, out Entity entity, out ArchetypeChunk chunk, out int indexInChunk)
			{
				iteration    = Iteration;
				entity       = Entity;
				chunk        = Chunk;
				indexInChunk = IndexInChunk;
			}
        }

        private ComponentSystemBase System;

        public EntityEnumerable_SBBBBB(ComponentSystemBase system, EntityQuery query, ref T0 s0, ref DynamicBuffer<T1> b1, ref DynamicBuffer<T2> b2, ref DynamicBuffer<T3> b3, ref DynamicBuffer<T4> b4, ref DynamicBuffer<T5> b5)
        {
			m_Chunks = query.CreateArchetypeChunkArray(Allocator.TempJob);

            System = system;
			m_EntityType = system.GetArchetypeChunkEntityType();

            ChunkComponentType0 = system.GetArchetypeChunkSharedComponentType<T0>();
            Address0 = UnsafeUtility.AddressOf(ref s0);
            ChunkComponentType1 = system.GetArchetypeChunkBufferType<T1>(false);
            Address1 = UnsafeUtility.AddressOf(ref b1);
            ChunkComponentType2 = system.GetArchetypeChunkBufferType<T2>(false);
            Address2 = UnsafeUtility.AddressOf(ref b2);
            ChunkComponentType3 = system.GetArchetypeChunkBufferType<T3>(false);
            Address3 = UnsafeUtility.AddressOf(ref b3);
            ChunkComponentType4 = system.GetArchetypeChunkBufferType<T4>(false);
            Address4 = UnsafeUtility.AddressOf(ref b4);
            ChunkComponentType5 = system.GetArchetypeChunkBufferType<T5>(false);
            Address5 = UnsafeUtility.AddressOf(ref b5);
        }

        private NativeArray<ArchetypeChunk> m_Chunks;
        private ArchetypeChunkEntityType m_EntityType;

        public Enumerator GetEnumerator()
        {
            return new Enumerator
            {
				Chunks       = m_Chunks,
				EntityType   = m_EntityType,
				SizeOfEntity = sizeof(Entity),

                System = System,

                ChunkComponentType0 = this.ChunkComponentType0,
                Address0 = this.Address0,
                SizeOf0 = UnsafeUtility.SizeOf<T0>(),
                ChunkComponentType1 = this.ChunkComponentType1,
                Address1 = this.Address1,
                SizeOf1 = UnsafeUtility.SizeOf<T1>(),
                ChunkComponentType2 = this.ChunkComponentType2,
                Address2 = this.Address2,
                SizeOf2 = UnsafeUtility.SizeOf<T2>(),
                ChunkComponentType3 = this.ChunkComponentType3,
                Address3 = this.Address3,
                SizeOf3 = UnsafeUtility.SizeOf<T3>(),
                ChunkComponentType4 = this.ChunkComponentType4,
                Address4 = this.Address4,
                SizeOf4 = UnsafeUtility.SizeOf<T4>(),
                ChunkComponentType5 = this.ChunkComponentType5,
                Address5 = this.Address5,
                SizeOf5 = UnsafeUtility.SizeOf<T5>(),
            };
        }
        private ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
        private void* Address0;
        private ArchetypeChunkBufferType<T1> ChunkComponentType1;
        private void* Address1;
        private ArchetypeChunkBufferType<T2> ChunkComponentType2;
        private void* Address2;
        private ArchetypeChunkBufferType<T3> ChunkComponentType3;
        private void* Address3;
        private ArchetypeChunkBufferType<T4> ChunkComponentType4;
        private void* Address4;
        private ArchetypeChunkBufferType<T5> ChunkComponentType5;
        private void* Address5;
        public struct Enumerator : IEnumerator<Item>
        {
			public bool MoveNext()
			{
				if (m_Item.Chunk != default)
				{
                    if (m_Item.Chunk.Invalid())
                        throw new InvalidOperationException("Invalid Chunks");
				}

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				var previousChunk = m_Item.Chunk;
				if (previousChunk != default && m_EntityIndex >= previousChunk.Count)
					m_ChunkIndex++;

				if (m_ChunkIndex >= Chunks.Length)
					return false;

				m_Item.Chunk = Chunks[m_ChunkIndex];
				if (m_Item.Chunk == default)
					return false;
                if (m_Item.Chunk.Invalid())
                    throw new InvalidOperationException("Invalid Chunks");

				if (previousChunk != m_Item.Chunk)
				{
					m_EntityIndex    = 0;
					EntityArray      = m_Item.Chunk.GetNativeArray(EntityType).GetUnsafeReadOnlyPtr();
                    Array0 = m_Item.Chunk.GetSharedComponentData(ChunkComponentType0, System.EntityManager);
                    Array1 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType1);
                    Array2 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType2);
                    Array3 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType3);
                    Array4 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType4);
                    Array5 = m_Item.Chunk.GetBufferAccessor(ChunkComponentType5);
				}

				m_Item.Chunk        = Chunks[m_ChunkIndex];
				m_Item.Iteration    = m_Iteration++;
				m_Item.IndexInChunk = m_EntityIndex;

				UnsafeUtility.MemCpy(UnsafeUtility.AddressOf(ref m_Item.Entity), (byte*) EntityArray + m_EntityIndex * SizeOfEntity, SizeOfEntity);
                UnsafeUtility.MemCpy(Address0, UnsafeUtility.AddressOf(ref Array0), SizeOf0);;
                var tmp1 = Array1[m_EntityIndex]; UnsafeUtility.MemCpy(Address1, UnsafeUtility.AddressOf(ref tmp1), SizeOf1);;
                var tmp2 = Array2[m_EntityIndex]; UnsafeUtility.MemCpy(Address2, UnsafeUtility.AddressOf(ref tmp2), SizeOf2);;
                var tmp3 = Array3[m_EntityIndex]; UnsafeUtility.MemCpy(Address3, UnsafeUtility.AddressOf(ref tmp3), SizeOf3);;
                var tmp4 = Array4[m_EntityIndex]; UnsafeUtility.MemCpy(Address4, UnsafeUtility.AddressOf(ref tmp4), SizeOf4);;
                var tmp5 = Array5[m_EntityIndex]; UnsafeUtility.MemCpy(Address5, UnsafeUtility.AddressOf(ref tmp5), SizeOf5);;
				m_EntityIndex++;

				return true;
			}

			public void Reset()
			{

			}

            public void Dispose()
            {
                Chunks.Dispose();
            }

            private int m_Iteration;
			private int m_ChunkIndex;
			private int m_EntityIndex;

			private Item m_Item;
			
			public Item Current => m_Item;

			object IEnumerator.Current => Current;

            public ComponentSystemBase System;
			public NativeArray<ArchetypeChunk> Chunks;            

            public ArchetypeChunkEntityType        EntityType;
			public void*                           EntityArray;
			public int                             SizeOfEntity;
            public ArchetypeChunkSharedComponentType<T0> ChunkComponentType0;
            public void* Address0;
            public T0 Array0;
            public int SizeOf0;
            public ArchetypeChunkBufferType<T1> ChunkComponentType1;
            public void* Address1;
            public BufferAccessor<T1> Array1;
            public int SizeOf1;
            public ArchetypeChunkBufferType<T2> ChunkComponentType2;
            public void* Address2;
            public BufferAccessor<T2> Array2;
            public int SizeOf2;
            public ArchetypeChunkBufferType<T3> ChunkComponentType3;
            public void* Address3;
            public BufferAccessor<T3> Array3;
            public int SizeOf3;
            public ArchetypeChunkBufferType<T4> ChunkComponentType4;
            public void* Address4;
            public BufferAccessor<T4> Array4;
            public int SizeOf4;
            public ArchetypeChunkBufferType<T5> ChunkComponentType5;
            public void* Address5;
            public BufferAccessor<T5> Array5;
            public int SizeOf5;
        }
    }
    }
} // namespace Unity.Entities

